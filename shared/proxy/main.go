// sq-secret-proxy-https — MITM proxy for transparent HTTPS credential injection.
//
// Listens on :8888, handles three cases:
//   1. Plain HTTP — rewrite headers, forward via DefaultTransport
//   2. HTTPS CONNECT to allowed host — MITM with generated cert, rewrite headers
//   3. HTTPS CONNECT to other hosts — blind TCP tunnel (no inspection)
//
// Requires SQUASH_DATA env var pointing to a directory containing:
//   - secrets.json  (secret definitions with placeholders + allowed_hosts)
//   - proxy-ca/     (ca.crt + ca.key generated by entrypoint.sh)

package main

import (
	"bufio"
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rand"
	"crypto/tls"
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding/json"
	"encoding/pem"
	"fmt"
	"io"
	"log"
	"math/big"
	"net"
	"net/http"
	"os"
	"strings"
	"sync"
	"sync/atomic"
	"time"
)

// ── Limits ───────────────────────────────────────────────────────────

const (
	maxCertCacheSize   = 1000               // max cached TLS certs (bounded by allowed_hosts in practice)
	maxResponseBody    = 512 * 1024 * 1024  // 512 MB max response relay
	maxRequestBody     = 64 * 1024 * 1024   // 64 MB max request body
	maxConcurrentConns = 512                // max simultaneous proxy connections
	connIdleTimeout    = 2 * time.Minute    // idle timeout for MITM/tunnel connections
	connReadTimeout    = 30 * time.Second   // read timeout per request in MITM loop
	tunnelTimeout      = 10 * time.Minute   // max duration for a TCP tunnel
)

// connSemaphore limits concurrent proxy connections.
var connSemaphore = make(chan struct{}, maxConcurrentConns)

func acquireConn() bool {
	select {
	case connSemaphore <- struct{}{}:
		return true
	default:
		return false
	}
}

func releaseConn() {
	<-connSemaphore
}

// ── Secret config ────────────────────────────────────────────────────

type Secret struct {
	Placeholder  string   `json:"placeholder"`
	Value        string   `json:"value"`
	AllowedHosts []string `json:"allowed_hosts"`
}

type SecretsFile struct {
	Secrets map[string]Secret `json:"secrets"`
}

func loadSecrets(path string) *SecretsFile {
	data, err := os.ReadFile(path)
	if err != nil {
		log.Fatalf("cannot read secrets file: %v", err)
	}
	var sf SecretsFile
	if err := json.Unmarshal(data, &sf); err != nil {
		log.Fatalf("cannot parse secrets file: %v", err)
	}
	return &sf
}

// hostAllowed checks if a hostname is in any secret's allowed_hosts list.
func (sf *SecretsFile) hostAllowed(host string) bool {
	for _, s := range sf.Secrets {
		for _, h := range s.AllowedHosts {
			if h == host {
				return true
			}
		}
	}
	return false
}

// ── CA + cert generation ─────────────────────────────────────────────

func loadCA(dir string) (*x509.Certificate, *ecdsa.PrivateKey) {
	certPEM, err := os.ReadFile(dir + "/ca.crt")
	if err != nil {
		log.Fatalf("cannot read CA cert: %v", err)
	}
	keyPEM, err := os.ReadFile(dir + "/ca.key")
	if err != nil {
		log.Fatalf("cannot read CA key: %v", err)
	}

	certBlock, _ := pem.Decode(certPEM)
	if certBlock == nil {
		log.Fatal("cannot decode CA cert PEM")
	}
	caCert, err := x509.ParseCertificate(certBlock.Bytes)
	if err != nil {
		log.Fatalf("cannot parse CA cert: %v", err)
	}

	keyBlock, _ := pem.Decode(keyPEM)
	if keyBlock == nil {
		log.Fatal("cannot decode CA key PEM")
	}

	// Try PKCS#8 first (OpenSSL default for EC keys), fall back to SEC 1
	var caKey *ecdsa.PrivateKey
	if key, err := x509.ParsePKCS8PrivateKey(keyBlock.Bytes); err == nil {
		var ok bool
		caKey, ok = key.(*ecdsa.PrivateKey)
		if !ok {
			log.Fatal("CA key is not ECDSA")
		}
	} else if key, err := x509.ParseECPrivateKey(keyBlock.Bytes); err == nil {
		caKey = key
	} else {
		log.Fatalf("cannot parse CA key: %v", err)
	}

	return caCert, caKey
}

// certCache is a bounded LRU-ish cert cache. When full, it's cleared entirely
// (simple and sufficient — allowed_hosts is typically < 10 entries).
type certCache struct {
	mu    sync.RWMutex
	certs map[string]*tls.Certificate
	size  int
}

func newCertCache(maxSize int) *certCache {
	return &certCache{
		certs: make(map[string]*tls.Certificate),
		size:  maxSize,
	}
}

func (c *certCache) get(host string) (*tls.Certificate, bool) {
	c.mu.RLock()
	defer c.mu.RUnlock()
	cert, ok := c.certs[host]
	return cert, ok
}

func (c *certCache) put(host string, cert *tls.Certificate) {
	c.mu.Lock()
	defer c.mu.Unlock()
	if len(c.certs) >= c.size {
		// Evict all — simple reset, certs regenerate on demand
		c.certs = make(map[string]*tls.Certificate)
		log.Printf("cert cache full (%d), cleared", c.size)
	}
	c.certs[host] = cert
}

func generateCert(host string, caCert *x509.Certificate, caKey *ecdsa.PrivateKey, cache *certCache) (*tls.Certificate, error) {
	if cert, ok := cache.get(host); ok {
		return cert, nil
	}

	leafKey, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
	if err != nil {
		return nil, fmt.Errorf("generate key: %w", err)
	}

	serial, err := rand.Int(rand.Reader, new(big.Int).Lsh(big.NewInt(1), 128))
	if err != nil {
		return nil, fmt.Errorf("generate serial: %w", err)
	}

	template := &x509.Certificate{
		SerialNumber: serial,
		Subject:      pkix.Name{CommonName: host},
		NotBefore:    time.Now().Add(-1 * time.Minute),
		NotAfter:     time.Now().Add(24 * time.Hour),
		KeyUsage:     x509.KeyUsageDigitalSignature,
		ExtKeyUsage:  []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
		DNSNames:     []string{host},
	}

	leafDER, err := x509.CreateCertificate(rand.Reader, template, caCert, &leafKey.PublicKey, caKey)
	if err != nil {
		return nil, fmt.Errorf("sign cert: %w", err)
	}

	tlsCert := &tls.Certificate{
		Certificate: [][]byte{leafDER, caCert.Raw},
		PrivateKey:  leafKey,
	}

	cache.put(host, tlsCert)
	return tlsCert, nil
}

// ── Hop-by-hop headers ───────────────────────────────────────────────

// Headers that must not be forwarded by a proxy (RFC 2616 §13.5.1).
var hopByHopHeaders = []string{
	"Connection",
	"Keep-Alive",
	"Proxy-Authenticate",
	"Proxy-Authorization",
	"Proxy-Connection",
	"Te",
	"Trailer",
	"Transfer-Encoding",
	"Upgrade",
}

func stripHopByHop(h http.Header) {
	for _, k := range hopByHopHeaders {
		h.Del(k)
	}
}

// ── Header replacement allow-list ────────────────────────────────────

// Only replace placeholders in headers that carry credentials.
// This prevents accidental secret leakage into arbitrary headers.
var replaceableHeaders = map[string]bool{
	"Authorization":       true,
	"X-Api-Key":           true,
	"Api-Key":             true,
	"X-Auth-Token":        true,
	"X-Access-Token":      true,
	"Proxy-Authorization": true, // replaced before hop-by-hop strip
}

// ── Proxy handler ────────────────────────────────────────────────────

type ProxyHandler struct {
	secrets   *SecretsFile
	caCert    *x509.Certificate
	caKey     *ecdsa.PrivateKey
	certCache *certCache
	active    atomic.Int64 // track active connections for diagnostics
}

func (p *ProxyHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	if !acquireConn() {
		http.Error(w, "too many connections", http.StatusServiceUnavailable)
		return
	}
	p.active.Add(1)
	defer func() {
		p.active.Add(-1)
		releaseConn()
	}()

	if r.Method == http.MethodConnect {
		p.handleConnect(w, r)
	} else {
		p.handleHTTP(w, r)
	}
}

// handleHTTP forwards plain HTTP requests with header replacement.
func (p *ProxyHandler) handleHTTP(w http.ResponseWriter, r *http.Request) {
	host := r.URL.Hostname()

	p.replaceHeaders(r, host)
	stripHopByHop(r.Header)

	// Limit request body
	var body io.Reader = r.Body
	if r.Body != nil {
		body = io.LimitReader(r.Body, maxRequestBody)
	}

	outReq, err := http.NewRequest(r.Method, r.URL.String(), body)
	if err != nil {
		http.Error(w, "bad request", http.StatusBadRequest)
		return
	}
	outReq.Header = r.Header.Clone()

	resp, err := http.DefaultTransport.RoundTrip(outReq)
	if err != nil {
		http.Error(w, "upstream error", http.StatusBadGateway)
		return
	}
	defer resp.Body.Close()

	// Copy response headers, stripping hop-by-hop
	for k, vv := range resp.Header {
		for _, v := range vv {
			w.Header().Add(k, v)
		}
	}
	stripHopByHop(w.Header())
	w.WriteHeader(resp.StatusCode)
	io.Copy(w, io.LimitReader(resp.Body, maxResponseBody))
}

// handleConnect handles HTTPS CONNECT tunnels.
func (p *ProxyHandler) handleConnect(w http.ResponseWriter, r *http.Request) {
	// Extract host (strip port)
	host := r.Host
	if h, _, err := net.SplitHostPort(host); err == nil {
		host = h
	}

	hijacker, ok := w.(http.Hijacker)
	if !ok {
		http.Error(w, "hijack not supported", http.StatusInternalServerError)
		return
	}
	clientConn, _, err := hijacker.Hijack()
	if err != nil {
		log.Printf("hijack error: %v", err)
		return
	}
	defer clientConn.Close()

	clientConn.Write([]byte("HTTP/1.1 200 Connection Established\r\n\r\n"))

	if p.secrets.hostAllowed(host) {
		p.tlsMITM(clientConn, host, r.Host)
	} else {
		p.tcpTunnel(clientConn, r.Host)
	}
}

// tlsMITM terminates TLS with a generated cert, reads plaintext, replaces headers, forwards.
func (p *ProxyHandler) tlsMITM(clientConn net.Conn, host, hostPort string) {
	cert, err := generateCert(host, p.caCert, p.caKey, p.certCache)
	if err != nil {
		log.Printf("cert generation error for %s: %v", host, err)
		return
	}

	tlsConn := tls.Server(clientConn, &tls.Config{
		Certificates: []tls.Certificate{*cert},
		MinVersion:   tls.VersionTLS12,
	})
	if err := tlsConn.Handshake(); err != nil {
		log.Printf("TLS handshake error for %s: %v", host, err)
		return
	}
	defer tlsConn.Close()

	// Ensure hostPort has a port
	if _, _, err := net.SplitHostPort(hostPort); err != nil {
		hostPort = hostPort + ":443"
	}

	// Read requests from the TLS connection and forward them
	br := bufio.NewReader(tlsConn)
	for {
		// Per-request read deadline
		tlsConn.SetReadDeadline(time.Now().Add(connIdleTimeout))

		req, err := http.ReadRequest(br)
		if err != nil {
			if err != io.EOF {
				if ne, ok := err.(net.Error); ok && ne.Timeout() {
					// Idle timeout — clean close
					return
				}
				log.Printf("read request error for %s: %v", host, err)
			}
			return
		}

		// Clear read deadline for the forwarding phase
		tlsConn.SetReadDeadline(time.Time{})

		// Fix up the request URL for forwarding
		req.URL.Scheme = "https"
		req.URL.Host = hostPort
		req.RequestURI = ""

		// Limit request body
		if req.Body != nil {
			req.Body = io.NopCloser(io.LimitReader(req.Body, maxRequestBody))
		}

		p.replaceHeaders(req, host)
		stripHopByHop(req.Header)

		// Set write deadline for sending response back
		tlsConn.SetWriteDeadline(time.Now().Add(connReadTimeout))

		resp, err := http.DefaultTransport.RoundTrip(req)
		if err != nil {
			log.Printf("upstream error for %s: %v", host, err)
			tlsConn.Write([]byte("HTTP/1.1 502 Bad Gateway\r\nContent-Length: 0\r\n\r\n"))
			return
		}

		// Limit response body before relaying
		resp.Body = io.NopCloser(io.LimitReader(resp.Body, maxResponseBody))

		err = resp.Write(tlsConn)
		resp.Body.Close()

		// Clear write deadline
		tlsConn.SetWriteDeadline(time.Time{})

		if err != nil {
			return
		}

		if resp.Close || req.Close {
			return
		}
	}
}

// tcpTunnel does a blind bidirectional copy (no inspection).
func (p *ProxyHandler) tcpTunnel(clientConn net.Conn, hostPort string) {
	// Ensure hostPort has a port
	if _, _, err := net.SplitHostPort(hostPort); err != nil {
		hostPort = hostPort + ":443"
	}

	upstream, err := net.DialTimeout("tcp", hostPort, 10*time.Second)
	if err != nil {
		log.Printf("tunnel dial error for %s: %v", hostPort, err)
		return
	}
	defer upstream.Close()

	// Set absolute deadline on the tunnel to prevent indefinite connections
	deadline := time.Now().Add(tunnelTimeout)
	clientConn.SetDeadline(deadline)
	upstream.SetDeadline(deadline)

	done := make(chan struct{}, 2)
	go func() {
		io.Copy(upstream, clientConn)
		done <- struct{}{}
	}()
	go func() {
		io.Copy(clientConn, upstream)
		done <- struct{}{}
	}()
	<-done
}

// replaceHeaders scans auth-related request headers for placeholder strings
// and replaces them with real values, only if the destination host is allowed.
func (p *ProxyHandler) replaceHeaders(r *http.Request, host string) {
	for name, values := range r.Header {
		if !replaceableHeaders[http.CanonicalHeaderKey(name)] {
			continue
		}
		for i, v := range values {
			for secretName, secret := range p.secrets.Secrets {
				if !strings.Contains(v, secret.Placeholder) {
					continue
				}
				allowed := false
				for _, h := range secret.AllowedHosts {
					if h == host {
						allowed = true
						break
					}
				}
				if allowed {
					values[i] = strings.ReplaceAll(v, secret.Placeholder, secret.Value)
					log.Printf("replaced %s in %s for %s", secretName, name, host)
				} else {
					log.Printf("blocked %s — host %s not in allowed_hosts", secretName, host)
				}
			}
		}
	}
}

// ── Main ─────────────────────────────────────────────────────────────

func main() {
	dataDir := os.Getenv("SQUASH_DATA")
	if dataDir == "" {
		dataDir = "/data"
	}

	secretsFile := dataDir + "/secrets.json"
	caDir := dataDir + "/proxy-ca"

	secrets := loadSecrets(secretsFile)
	caCert, caKey := loadCA(caDir)

	handler := &ProxyHandler{
		secrets:   secrets,
		caCert:    caCert,
		caKey:     caKey,
		certCache: newCertCache(maxCertCacheSize),
	}

	server := &http.Server{
		Addr:         ":8888",
		Handler:      handler,
		ReadTimeout:  30 * time.Second,
		WriteTimeout: 0, // disabled — CONNECT hijacks bypass this anyway
		IdleTimeout:  connIdleTimeout,
	}

	log.Printf("sq-secret-proxy-https starting on :8888 (%d secrets configured)", len(secrets.Secrets))
	if err := server.ListenAndServe(); err != nil {
		log.Fatalf("server error: %v", err)
	}
}
