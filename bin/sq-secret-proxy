#!/bin/sh
# sq-secret-proxy — credential-injecting HTTP proxy
# Listens on port 8888, intercepts outbound HTTP requests from sandboxes,
# replaces placeholder secrets with real values for approved hosts.
#
# NOTE: This is an HTTP-only proxy. Production HTTPS support (CONNECT tunneling
# with header rewriting) needs a compiled Go/Rust binary (~200 lines).
# See docs/plan-firecracker-and-security.md Phase 6 for details.
set -eu

SECRETS_FILE="${SQUASH_DATA:-/data}/secrets.json"
PORT=8888

if [ ! -f "$SECRETS_FILE" ]; then
    echo "[sq-secret-proxy] no secrets file at $SECRETS_FILE, exiting" >&2
    exit 0
fi

echo "[sq-secret-proxy] starting on port $PORT" >&2

# handler script — socat forks one per connection
handle_connection() {
    local secrets_file="$1"

    # Read the HTTP request line
    local request_line=""
    IFS= read -r request_line
    request_line=$(printf '%s' "$request_line" | tr -d '\r')

    local method url _httpver
    method=$(echo "$request_line" | awk '{print $1}')
    url=$(echo "$request_line" | awk '{print $2}')

    # Extract destination host from URL
    local host=""
    host=$(echo "$url" | sed -n 's|https\?://\([^/:]*\).*|\1|p')

    # Read headers until blank line
    local headers=""
    local body_length=0
    while IFS= read -r line; do
        line=$(printf '%s' "$line" | tr -d '\r')
        [ -z "$line" ] && break

        # Track content-length
        case "$line" in
            Content-Length:*|content-length:*)
                body_length=$(echo "$line" | awk '{print $2}')
                ;;
        esac

        # Scan for placeholder values and replace with real secrets
        for key in $(jq -r '.secrets | keys[]' "$secrets_file" 2>/dev/null); do
            placeholder=$(jq -r ".secrets[\"$key\"].placeholder" "$secrets_file")

            # Check if this header contains the placeholder
            case "$line" in
                *"$placeholder"*)
                    # Verify destination host is in allowed_hosts for this secret
                    if jq -e ".secrets[\"$key\"].allowed_hosts[]" "$secrets_file" 2>/dev/null \
                        | grep -qF "$host"; then
                        real=$(jq -r ".secrets[\"$key\"].value" "$secrets_file")
                        line=$(echo "$line" | sed "s|$placeholder|$real|g")
                        echo "[sq-secret-proxy] replaced $key placeholder for host $host" >&2
                    else
                        echo "[sq-secret-proxy] blocked $key replacement — host $host not allowed" >&2
                    fi
                    ;;
            esac
        done

        headers="$headers$line
"
    done

    # Read body if present
    local body=""
    if [ "$body_length" -gt 0 ] 2>/dev/null; then
        body=$(dd bs=1 count="$body_length" 2>/dev/null)
    fi

    # Forward request via curl -K (config file, avoids eval)
    local header_file
    header_file=$(mktemp)
    printf '%s' "$headers" > "$header_file"

    local response_file
    response_file=$(mktemp)

    local curl_cfg
    curl_cfg=$(mktemp)
    printf -- '-s\n-S\n--max-time 30\n' > "$curl_cfg"
    printf 'request = "%s"\n' "$method" >> "$curl_cfg"
    printf 'url = "%s"\n' "$url" >> "$curl_cfg"
    printf -- '-D "%s.hdr"\n' "$response_file" >> "$curl_cfg"
    printf -- '-o "%s"\n' "$response_file" >> "$curl_cfg"

    # Add headers from file
    while IFS= read -r h; do
        [ -z "$h" ] && continue
        printf 'header = "%s"\n' "$h" >> "$curl_cfg"
    done < "$header_file"

    if [ -n "$body" ]; then
        local body_file
        body_file=$(mktemp)
        printf '%s' "$body" > "$body_file"
        printf 'data-binary = "@%s"\n' "$body_file" >> "$curl_cfg"
        curl -K "$curl_cfg" 2>/dev/null
        rm -f "$body_file"
    else
        curl -K "$curl_cfg" 2>/dev/null
    fi

    rm -f "$curl_cfg"

    # Return response to caller
    if [ -f "$response_file.hdr" ]; then
        cat "$response_file.hdr"
    else
        printf 'HTTP/1.1 502 Bad Gateway\r\n\r\n'
    fi
    [ -f "$response_file" ] && cat "$response_file"

    rm -f "$header_file" "$response_file" "$response_file.hdr"
}

export -f handle_connection 2>/dev/null || true

# socat forks a handler per inbound connection
exec socat "TCP-LISTEN:$PORT,reuseaddr,fork" \
    EXEC:"/bin/sh -c 'handle_connection \"$SECRETS_FILE\"'"
