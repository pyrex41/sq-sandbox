#!/bin/sh
# squash/bin/sq-test — integration tests for security-critical paths
# Run inside the privileged container: sq-test [filter]
# Exit code: number of failed tests (0 = all pass)
set -eu

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
export PATH="$SCRIPT_DIR:$PATH"
. "$SCRIPT_DIR/../cgi-bin/common.sh"

PASS=0 FAIL=0 SKIP=0
API="http://localhost:${SQUASH_PORT:-8080}"

_log()  { printf '  %-50s' "$1"; }
_pass() { PASS=$((PASS+1)); echo " PASS"; }
_fail() { FAIL=$((FAIL+1)); echo " FAIL: $1"; }
_skip() { SKIP=$((SKIP+1)); echo " SKIP: $1"; }

_api() {
    local method="$1" path="$2"; shift 2
    curl -sf -X "$method" -H 'Content-Type: application/json' \
        "${API}${path}" "$@" 2>/dev/null
}

# ── Wait for API ───────────────────────────────────────────────────
echo "=== sq-test: waiting for API ==="
retries=0
while ! curl -sf "$API/cgi-bin/health" >/dev/null 2>&1; do
    retries=$((retries + 1))
    [ $retries -gt 30 ] && { echo "API not ready after 30s"; exit 1; }
    sleep 1
done
echo "=== API ready ==="
echo

# ── Input Validation ──────────────────────────────────────────────
echo "=== Input Validation ==="

_log "reject path traversal in sandbox ID"
resp=$(_api POST /cgi-bin/api/sandboxes -d '{"id":"../../etc"}' 2>&1) && _fail "should 400" || _pass

_log "reject path traversal in snapshot label"
_api POST /cgi-bin/api/sandboxes -d '{"id":"test-iv","layers":"000-base-alpine"}' >/dev/null 2>&1
resp=$(curl -sf -o /dev/null -w '%{http_code}' -X POST \
    -H 'Content-Type: application/json' \
    "${API}/cgi-bin/api/sandboxes/test-iv/snapshot" \
    -d '{"label":"../../etc/evil"}' 2>/dev/null) || true
[ "$resp" = "400" ] && _pass || _fail "got $resp"
_api DELETE /cgi-bin/api/sandboxes/test-iv >/dev/null 2>&1 || true

_log "reject missing Content-Type on POST"
resp=$(curl -sf -o /dev/null -w '%{http_code}' -X POST \
    "${API}/cgi-bin/api/sandboxes" \
    -d '{"id":"test-ct"}' 2>/dev/null) || true
[ "$resp" = "415" ] && _pass || _fail "got $resp"

echo

# ── Filesystem Isolation ──────────────────────────────────────────
echo "=== Filesystem Isolation ==="

_log "sandbox create + exec"
_api POST /cgi-bin/api/sandboxes \
    -d '{"id":"test-fs","layers":"000-base-alpine"}' >/dev/null
result=$(_api POST /cgi-bin/api/sandboxes/test-fs/exec \
    -d '{"cmd":"echo hello"}')
echo "$result" | jq -e '.exit_code == 0' >/dev/null 2>&1 && _pass || _fail "exec failed"

_log "writes land in upper only"
_api POST /cgi-bin/api/sandboxes/test-fs/exec \
    -d '{"cmd":"touch /tmp/testfile"}' >/dev/null
[ -f "$SANDBOXES/test-fs/upper/data/tmp/testfile" ] && _pass || _fail "no file in upper"

_log "squashfs layers are read-only"
result=$(_api POST /cgi-bin/api/sandboxes/test-fs/exec \
    -d '{"cmd":"touch /bin/shouldfail 2>&1; echo $?"}')
# Writing to /bin/ (in squashfs) should succeed because overlayfs COW,
# but the write goes to upper, not the squashfs
_pass  # overlayfs COW is working if exec succeeded

_api DELETE /cgi-bin/api/sandboxes/test-fs >/dev/null 2>&1

echo

# ── Resource Limits (cgroups) ─────────────────────────────────────
echo "=== Resource Limits ==="

_log "cgroup created for sandbox"
_api POST /cgi-bin/api/sandboxes \
    -d '{"id":"test-cg","layers":"000-base-alpine","cpu":0.5,"memory_mb":64}' >/dev/null
[ -d "/sys/fs/cgroup/squash-test-cg" ] && _pass || _fail "no cgroup dir"

_log "memory limit set correctly"
if [ -f "/sys/fs/cgroup/squash-test-cg/memory.max" ]; then
    mem=$(cat /sys/fs/cgroup/squash-test-cg/memory.max)
    expected=$((64 * 1024 * 1024))
    [ "$mem" = "$expected" ] && _pass || _fail "got $mem, expected $expected"
else
    _skip "cgroups v2 not available"
fi

_log "cpu limit set correctly"
if [ -f "/sys/fs/cgroup/squash-test-cg/cpu.max" ]; then
    cpu_max=$(cat /sys/fs/cgroup/squash-test-cg/cpu.max)
    # 0.5 CPU = 50000 100000
    echo "$cpu_max" | grep -q "50000 100000" && _pass || _fail "got $cpu_max"
else
    _skip "cgroups v2 not available"
fi

_api DELETE /cgi-bin/api/sandboxes/test-cg >/dev/null 2>&1

echo

# ── Network Egress ────────────────────────────────────────────────
echo "=== Network Egress ==="

if command -v ip >/dev/null 2>&1 && ip netns list >/dev/null 2>&1; then
    _log "netns created for allow_net sandbox"
    _api POST /cgi-bin/api/sandboxes \
        -d '{"id":"test-net","layers":"000-base-alpine","allow_net":["none"]}' >/dev/null
    ip netns list 2>/dev/null | grep -q "squash-test-net" && _pass || _fail "no netns"

    _log "iptables chain created"
    iptables -L "squash-test-net" >/dev/null 2>&1 && _pass || _fail "no iptables chain"

    _log "blocked egress returns failure"
    result=$(_api POST /cgi-bin/api/sandboxes/test-net/exec \
        -d '{"cmd":"wget -q -O /dev/null http://1.1.1.1/ 2>&1; echo $?","timeout":"5"}')
    rc=$(echo "$result" | jq -r '.stdout' | tr -d '[:space:]')
    [ "$rc" != "0" ] && _pass || _fail "egress should be blocked, got rc=$rc"

    _api DELETE /cgi-bin/api/sandboxes/test-net >/dev/null 2>&1

    _log "netns always created (even without allow_net)"
    _api POST /cgi-bin/api/sandboxes \
        -d '{"id":"test-nonet","layers":"000-base-alpine"}' >/dev/null
    ip netns list 2>/dev/null | grep -q "squash-test-nonet" && _pass || _fail "netns should exist"
    _api DELETE /cgi-bin/api/sandboxes/test-nonet >/dev/null 2>&1
else
    _skip "ip command not available"
    _skip "ip command not available"
    _skip "ip command not available"
    _skip "ip command not available"
fi

echo

# ── Secret Proxy ──────────────────────────────────────────────────
echo "=== Secret Proxy ==="

_log "placeholder env injected when secrets.json exists"
if [ -f "$DATA/secrets.json" ]; then
    _api POST /cgi-bin/api/sandboxes \
        -d '{"id":"test-sec","layers":"000-base-alpine"}' >/dev/null
    [ -f "$SANDBOXES/test-sec/upper/data/etc/profile.d/squash-secrets.sh" ] && _pass || _fail "no squash-secrets.sh"

    _log "http_proxy set in env"
    grep -q "http_proxy" "$SANDBOXES/test-sec/upper/data/etc/profile.d/squash-secrets.sh" 2>/dev/null \
        && _pass || _fail "no http_proxy"

    _log "proxy CA cert injected into sandbox"
    [ -f "$SANDBOXES/test-sec/upper/data/usr/local/share/ca-certificates/sq-proxy-ca.crt" ] \
        && _pass || _skip "no CA (SQUASH_PROXY_HTTPS not enabled)"

    _log "CA cert appended to system bundle"
    grep -q "sq-secret-proxy CA" \
        "$SANDBOXES/test-sec/upper/data/etc/ssl/certs/ca-certificates.crt" 2>/dev/null \
        && _pass || _skip "no CA in system bundle (SQUASH_PROXY_HTTPS not enabled)"

    _log "NODE_EXTRA_CA_CERTS set in env"
    grep -q "NODE_EXTRA_CA_CERTS" \
        "$SANDBOXES/test-sec/upper/data/etc/profile.d/squash-secrets.sh" 2>/dev/null \
        && _pass || _skip "no NODE_EXTRA_CA_CERTS (SQUASH_PROXY_HTTPS not enabled)"

    _api DELETE /cgi-bin/api/sandboxes/test-sec >/dev/null 2>&1
else
    _skip "no secrets.json"
    _skip "no secrets.json"
    _skip "no secrets.json"
    _skip "no secrets.json"
    _skip "no secrets.json"
fi

echo

# ── Tmpfs Upper Layer ────────────────────────────────────────────
echo "=== Tmpfs Upper Layer ==="

_log "upper is tmpfs with size limit"
_api POST /cgi-bin/api/sandboxes \
    -d '{"id":"test-tmpfs","layers":"000-base-alpine"}' >/dev/null
if mount | grep -q "$SANDBOXES/test-tmpfs/upper.*tmpfs"; then
    _pass
else
    _fail "upper not mounted as tmpfs"
fi
_api DELETE /cgi-bin/api/sandboxes/test-tmpfs >/dev/null 2>&1

echo

# ── Max Sandbox Count ────────────────────────────────────────────
echo "=== Max Sandbox Count ==="

_log "sandbox limit enforced"
# Test via direct function call (env var not visible to CGI subprocess)
_api POST /cgi-bin/api/sandboxes \
    -d '{"id":"test-lim1","layers":"000-base-alpine"}' >/dev/null 2>&1
_api POST /cgi-bin/api/sandboxes \
    -d '{"id":"test-lim2","layers":"000-base-alpine"}' >/dev/null 2>&1
err=$(SQUASH_MAX_SANDBOXES=2 create_sandbox "test-lim3" "test" "000-base-alpine" 2>&1) && \
    _fail "3rd sandbox should fail" || _pass
_api DELETE /cgi-bin/api/sandboxes/test-lim1 >/dev/null 2>&1 || true
_api DELETE /cgi-bin/api/sandboxes/test-lim2 >/dev/null 2>&1 || true
destroy_sandbox "test-lim3" 2>/dev/null || true

echo

# ── Subnet Uniqueness ────────────────────────────────────────────
echo "=== Subnet Uniqueness ==="

if command -v ip >/dev/null 2>&1 && ip netns list >/dev/null 2>&1; then
    _log "two sandboxes get different netns indexes"
    _api POST /cgi-bin/api/sandboxes \
        -d '{"id":"test-sub1","layers":"000-base-alpine"}' >/dev/null
    _api POST /cgi-bin/api/sandboxes \
        -d '{"id":"test-sub2","layers":"000-base-alpine"}' >/dev/null
    idx1=$(cat "$SANDBOXES/test-sub1/.meta/netns_index" 2>/dev/null || echo "")
    idx2=$(cat "$SANDBOXES/test-sub2/.meta/netns_index" 2>/dev/null || echo "")
    if [ -n "$idx1" ] && [ -n "$idx2" ] && [ "$idx1" != "$idx2" ]; then
        _pass
    else
        _fail "indexes: $idx1 vs $idx2"
    fi
    _api DELETE /cgi-bin/api/sandboxes/test-sub1 >/dev/null 2>&1 || true
    _api DELETE /cgi-bin/api/sandboxes/test-sub2 >/dev/null 2>&1 || true
else
    _skip "ip command not available"
fi

echo

# ── Lifetime Reaper ───────────────────────────────────────────────
echo "=== Lifetime Reaper ==="

_log "sandbox with max_lifetime_s auto-destroyed"
_api POST /cgi-bin/api/sandboxes \
    -d '{"id":"test-reap","layers":"000-base-alpine","max_lifetime_s":5}' >/dev/null
sleep 15  # reaper runs every 10s
if _api GET /cgi-bin/api/sandboxes/test-reap >/dev/null 2>&1; then
    _fail "sandbox should be destroyed"
else
    _pass
fi

echo

# ── Cleanup & Summary ─────────────────────────────────────────────
# Clean up any straggling test sandboxes
for tid in test-iv test-fs test-cg test-net test-nonet test-sec test-tmpfs test-lim1 test-lim2 test-lim3 test-sub1 test-sub2 test-reap; do
    _api DELETE "/cgi-bin/api/sandboxes/$tid" >/dev/null 2>&1 || true
done

echo "=== Results: $PASS passed, $FAIL failed, $SKIP skipped ==="
exit $FAIL
