// sq-secret-proxy-https — MITM proxy for transparent HTTPS credential injection.
//
// Listens on :8888, handles three cases:
//   1. Plain HTTP — rewrite headers, forward via DefaultTransport
//   2. HTTPS CONNECT to allowed host — MITM with generated cert, rewrite headers
//   3. HTTPS CONNECT to other hosts — blind TCP tunnel (no inspection)
//
// Requires SQUASH_DATA env var pointing to a directory containing:
//   - secrets.json  (secret definitions with placeholders + allowed_hosts)
//   - proxy-ca/     (ca.crt + ca.key generated by entrypoint.sh)

package main

import (
	"bufio"
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rand"
	"crypto/tls"
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding/json"
	"encoding/pem"
	"fmt"
	"io"
	"log"
	"math/big"
	"net"
	"net/http"
	"os"
	"strings"
	"sync"
	"time"
)

// ── Secret config ────────────────────────────────────────────────────

type Secret struct {
	Placeholder  string   `json:"placeholder"`
	Value        string   `json:"value"`
	AllowedHosts []string `json:"allowed_hosts"`
}

type SecretsFile struct {
	Secrets map[string]Secret `json:"secrets"`
}

func loadSecrets(path string) *SecretsFile {
	data, err := os.ReadFile(path)
	if err != nil {
		log.Fatalf("cannot read secrets file: %v", err)
	}
	var sf SecretsFile
	if err := json.Unmarshal(data, &sf); err != nil {
		log.Fatalf("cannot parse secrets file: %v", err)
	}
	return &sf
}

// hostAllowed checks if a hostname is in any secret's allowed_hosts list.
func (sf *SecretsFile) hostAllowed(host string) bool {
	for _, s := range sf.Secrets {
		for _, h := range s.AllowedHosts {
			if h == host {
				return true
			}
		}
	}
	return false
}

// ── CA + cert generation ─────────────────────────────────────────────

func loadCA(dir string) (*x509.Certificate, *ecdsa.PrivateKey) {
	certPEM, err := os.ReadFile(dir + "/ca.crt")
	if err != nil {
		log.Fatalf("cannot read CA cert: %v", err)
	}
	keyPEM, err := os.ReadFile(dir + "/ca.key")
	if err != nil {
		log.Fatalf("cannot read CA key: %v", err)
	}

	certBlock, _ := pem.Decode(certPEM)
	if certBlock == nil {
		log.Fatal("cannot decode CA cert PEM")
	}
	caCert, err := x509.ParseCertificate(certBlock.Bytes)
	if err != nil {
		log.Fatalf("cannot parse CA cert: %v", err)
	}

	keyBlock, _ := pem.Decode(keyPEM)
	if keyBlock == nil {
		log.Fatal("cannot decode CA key PEM")
	}

	// Try PKCS#8 first (OpenSSL default for EC keys), fall back to SEC 1
	var caKey *ecdsa.PrivateKey
	if key, err := x509.ParsePKCS8PrivateKey(keyBlock.Bytes); err == nil {
		var ok bool
		caKey, ok = key.(*ecdsa.PrivateKey)
		if !ok {
			log.Fatal("CA key is not ECDSA")
		}
	} else if key, err := x509.ParseECPrivateKey(keyBlock.Bytes); err == nil {
		caKey = key
	} else {
		log.Fatalf("cannot parse CA key: %v", err)
	}

	return caCert, caKey
}

func generateCert(host string, caCert *x509.Certificate, caKey *ecdsa.PrivateKey, cache *sync.Map) (*tls.Certificate, error) {
	if cached, ok := cache.Load(host); ok {
		return cached.(*tls.Certificate), nil
	}

	leafKey, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
	if err != nil {
		return nil, fmt.Errorf("generate key: %w", err)
	}

	serial, err := rand.Int(rand.Reader, new(big.Int).Lsh(big.NewInt(1), 128))
	if err != nil {
		return nil, fmt.Errorf("generate serial: %w", err)
	}

	template := &x509.Certificate{
		SerialNumber: serial,
		Subject:      pkix.Name{CommonName: host},
		NotBefore:    time.Now().Add(-1 * time.Minute),
		NotAfter:     time.Now().Add(24 * time.Hour),
		KeyUsage:     x509.KeyUsageDigitalSignature,
		ExtKeyUsage:  []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
		DNSNames:     []string{host},
	}

	leafDER, err := x509.CreateCertificate(rand.Reader, template, caCert, &leafKey.PublicKey, caKey)
	if err != nil {
		return nil, fmt.Errorf("sign cert: %w", err)
	}

	tlsCert := &tls.Certificate{
		Certificate: [][]byte{leafDER, caCert.Raw},
		PrivateKey:  leafKey,
	}

	cache.Store(host, tlsCert)
	return tlsCert, nil
}

// ── Proxy handler ────────────────────────────────────────────────────

type ProxyHandler struct {
	secrets   *SecretsFile
	caCert    *x509.Certificate
	caKey     *ecdsa.PrivateKey
	certCache *sync.Map
}

func (p *ProxyHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	if r.Method == http.MethodConnect {
		p.handleConnect(w, r)
	} else {
		p.handleHTTP(w, r)
	}
}

// handleHTTP forwards plain HTTP requests with header replacement.
func (p *ProxyHandler) handleHTTP(w http.ResponseWriter, r *http.Request) {
	host := r.URL.Hostname()

	p.replaceHeaders(r, host)

	// Build outbound request
	outReq, err := http.NewRequest(r.Method, r.URL.String(), r.Body)
	if err != nil {
		http.Error(w, "bad request", http.StatusBadRequest)
		return
	}
	outReq.Header = r.Header.Clone()

	resp, err := http.DefaultTransport.RoundTrip(outReq)
	if err != nil {
		http.Error(w, "upstream error: "+err.Error(), http.StatusBadGateway)
		return
	}
	defer resp.Body.Close()

	// Copy response headers
	for k, vv := range resp.Header {
		for _, v := range vv {
			w.Header().Add(k, v)
		}
	}
	w.WriteHeader(resp.StatusCode)
	io.Copy(w, resp.Body)
}

// handleConnect handles HTTPS CONNECT tunnels.
func (p *ProxyHandler) handleConnect(w http.ResponseWriter, r *http.Request) {
	// Extract host (strip port)
	host := r.Host
	if h, _, err := net.SplitHostPort(host); err == nil {
		host = h
	}

	// Hijack the connection
	hijacker, ok := w.(http.Hijacker)
	if !ok {
		http.Error(w, "hijack not supported", http.StatusInternalServerError)
		return
	}
	clientConn, _, err := hijacker.Hijack()
	if err != nil {
		log.Printf("hijack error: %v", err)
		return
	}
	defer clientConn.Close()

	// Send 200 Connection Established
	clientConn.Write([]byte("HTTP/1.1 200 Connection Established\r\n\r\n"))

	if p.secrets.hostAllowed(host) {
		p.tlsMITM(clientConn, host, r.Host)
	} else {
		p.tcpTunnel(clientConn, r.Host)
	}
}

// tlsMITM terminates TLS with a generated cert, reads plaintext, replaces headers, forwards.
func (p *ProxyHandler) tlsMITM(clientConn net.Conn, host, hostPort string) {
	cert, err := generateCert(host, p.caCert, p.caKey, p.certCache)
	if err != nil {
		log.Printf("cert generation error for %s: %v", host, err)
		return
	}

	tlsConn := tls.Server(clientConn, &tls.Config{
		Certificates: []tls.Certificate{*cert},
	})
	if err := tlsConn.Handshake(); err != nil {
		log.Printf("TLS handshake error for %s: %v", host, err)
		return
	}
	defer tlsConn.Close()

	// Ensure hostPort has a port
	if _, _, err := net.SplitHostPort(hostPort); err != nil {
		hostPort = hostPort + ":443"
	}

	// Read requests from the TLS connection and forward them
	br := bufio.NewReader(tlsConn)
	for {
		req, err := http.ReadRequest(br)
		if err != nil {
			if err != io.EOF {
				log.Printf("read request error for %s: %v", host, err)
			}
			return
		}

		// Fix up the request URL for forwarding
		req.URL.Scheme = "https"
		req.URL.Host = hostPort
		req.RequestURI = ""

		p.replaceHeaders(req, host)

		resp, err := http.DefaultTransport.RoundTrip(req)
		if err != nil {
			log.Printf("upstream error for %s: %v", host, err)
			// Write a 502 back to the client
			tlsConn.Write([]byte("HTTP/1.1 502 Bad Gateway\r\nContent-Length: 0\r\n\r\n"))
			return
		}

		err = resp.Write(tlsConn)
		resp.Body.Close()
		if err != nil {
			return
		}

		// If the response or request indicates connection close, stop
		if resp.Close || req.Close {
			return
		}
	}
}

// tcpTunnel does a blind bidirectional copy (no inspection).
func (p *ProxyHandler) tcpTunnel(clientConn net.Conn, hostPort string) {
	// Ensure hostPort has a port
	if _, _, err := net.SplitHostPort(hostPort); err != nil {
		hostPort = hostPort + ":443"
	}

	upstream, err := net.DialTimeout("tcp", hostPort, 10*time.Second)
	if err != nil {
		log.Printf("tunnel dial error for %s: %v", hostPort, err)
		return
	}
	defer upstream.Close()

	done := make(chan struct{}, 2)
	go func() {
		io.Copy(upstream, clientConn)
		done <- struct{}{}
	}()
	go func() {
		io.Copy(clientConn, upstream)
		done <- struct{}{}
	}()
	<-done
}

// replaceHeaders scans request headers for placeholder strings and replaces
// them with real values, but only if the destination host is in allowed_hosts.
func (p *ProxyHandler) replaceHeaders(r *http.Request, host string) {
	for name, values := range r.Header {
		for i, v := range values {
			for secretName, secret := range p.secrets.Secrets {
				if !strings.Contains(v, secret.Placeholder) {
					continue
				}
				// Check if host is allowed for this secret
				allowed := false
				for _, h := range secret.AllowedHosts {
					if h == host {
						allowed = true
						break
					}
				}
				if allowed {
					values[i] = strings.ReplaceAll(v, secret.Placeholder, secret.Value)
					log.Printf("replaced %s placeholder in %s for host %s", secretName, name, host)
				} else {
					log.Printf("blocked %s replacement — host %s not allowed", secretName, host)
				}
			}
		}
	}
}

// ── Main ─────────────────────────────────────────────────────────────

func main() {
	dataDir := os.Getenv("SQUASH_DATA")
	if dataDir == "" {
		dataDir = "/data"
	}

	secretsFile := dataDir + "/secrets.json"
	caDir := dataDir + "/proxy-ca"

	secrets := loadSecrets(secretsFile)
	caCert, caKey := loadCA(caDir)
	certCache := &sync.Map{}

	handler := &ProxyHandler{
		secrets:   secrets,
		caCert:    caCert,
		caKey:     caKey,
		certCache: certCache,
	}

	server := &http.Server{
		Addr:    ":8888",
		Handler: handler,
	}

	log.Printf("sq-secret-proxy-https starting on :8888 (%d secrets configured)", len(secrets.Secrets))
	if err := server.ListenAndServe(); err != nil {
		log.Fatalf("server error: %v", err)
	}
}
