#!/bin/sh
# squash/bin/sq-firecracker â€” manage Firecracker microVMs for Squash sandboxes
set -eu

DATA="${SQUASH_DATA:-/data}"
VM_DIR="$DATA/vm"
FC="$VM_DIR/firecracker"
KERNEL="$VM_DIR/vmlinux"
ROOTFS="$VM_DIR/guest-rootfs.ext4"

CID_FILE="$DATA/.fc-cid-counter"
CID_LOCK="$DATA/.fc-cid-counter.lock"

_allocate_cid() {
    local cid
    (
        flock -x 9
        cid=$(cat "$CID_FILE" 2>/dev/null || echo 99)
        cid=$((cid + 1))
        echo "$cid" > "$CID_FILE"
        echo "$cid"
    ) 9>"$CID_LOCK"
}

# Start a Firecracker VM for a sandbox
# Usage: sq-firecracker start <sandbox-id> <cpu> <mem_mb> <squashfs1> [squashfs2 ...]
fc_start() {
    local id="$1" cpu="$2" mem="$3"; shift 3
    local sock="$DATA/sandboxes/$id/.meta/fc.sock"
    local pid_file="$DATA/sandboxes/$id/.meta/fc.pid"
    local log_file="$DATA/sandboxes/$id/.meta/fc.log"
    local cid_file="$DATA/sandboxes/$id/.meta/fc.cid"

    # Assign a unique CID for vsock (3+)
    local cid=$(_allocate_cid)
    echo "$cid" > "$cid_file"

    # Start Firecracker process
    rm -f "$sock"
    "$FC" --api-sock "$sock" > "$log_file" 2>&1 &
    echo $! > "$pid_file"
    sleep 0.5

    # Configure VM via API
    # Kernel + boot args
    local layer_count=$#
    local boot_args="console=ttyS0 reboot=k panic=1 pci=off squash.layers=$layer_count"
    jq -n --arg kernel "$KERNEL" --arg args "$boot_args" \
        '{kernel_image_path:$kernel,boot_args:$args}' \
    | curl -s --unix-socket "$sock" -X PUT "http://localhost/boot-source" \
        -H 'Content-Type: application/json' -d @-

    # Guest rootfs (vda)
    jq -n --arg path "$ROOTFS" \
        '{drive_id:"rootfs",path_on_host:$path,is_root_device:true,is_read_only:true}' \
    | curl -s --unix-socket "$sock" -X PUT "http://localhost/drives/rootfs" \
        -H 'Content-Type: application/json' -d @-

    # Squashfs layers as additional drives (vdb, vdc, ...)
    local i=0
    for sqfs in "$@"; do
        jq -n --arg did "layer$i" --arg path "$sqfs" \
            '{drive_id:$did,path_on_host:$path,is_root_device:false,is_read_only:true}' \
        | curl -s --unix-socket "$sock" -X PUT "http://localhost/drives/layer$i" \
            -H 'Content-Type: application/json' -d @-
        i=$((i + 1))
    done

    # Machine config
    jq -n --argjson vcpu "${cpu%.*}" --argjson mem "$mem" \
        '{vcpu_count:$vcpu,mem_size_mib:$mem}' \
    | curl -s --unix-socket "$sock" -X PUT "http://localhost/machine-config" \
        -H 'Content-Type: application/json' -d @-

    # Vsock
    jq -n --argjson cid "$cid" --arg uds "$DATA/sandboxes/$id/.meta/vsock.sock" \
        '{guest_cid:$cid,uds_path:$uds}' \
    | curl -s --unix-socket "$sock" -X PUT "http://localhost/vsock" \
        -H 'Content-Type: application/json' -d @-

    # Network (tap device created by _firecracker_setup_network before this call)
    jq -n --arg dev "sq-${id}-tap" \
        '{iface_id:"eth0",host_dev_name:$dev}' \
    | curl -s --unix-socket "$sock" -X PUT "http://localhost/network-interfaces/eth0" \
        -H 'Content-Type: application/json' -d @-

    # Boot the VM
    curl -s --unix-socket "$sock" -X PUT "http://localhost/actions" \
        -H 'Content-Type: application/json' \
        -d '{"action_type":"InstanceStart"}'

    # Wait for vsock to be ready
    local retries=0
    while [ $retries -lt 20 ]; do
        echo '{"cmd":"echo ready"}' | socat - VSOCK-CONNECT:$cid:5000 2>/dev/null && break
        retries=$((retries + 1))
        sleep 0.1
    done
}

# Send command to VM via vsock
# Usage: sq-firecracker exec <sandbox-id> <cmd> [workdir] [timeout]
fc_exec() {
    local id="$1" cmd="$2" workdir="${3:-/}" timeout="${4:-300}"
    local cid=$(cat "$DATA/sandboxes/$id/.meta/fc.cid")

    jq -n --arg cmd "$cmd" --arg wd "$workdir" --argjson t "$timeout" \
        '{cmd:$cmd,workdir:$wd,timeout:$t}' \
    | socat -T"$timeout" - VSOCK-CONNECT:$cid:5000
}

# Stop a Firecracker VM
# Usage: sq-firecracker stop <sandbox-id>
fc_stop() {
    local id="$1"
    local pid_file="$DATA/sandboxes/$id/.meta/fc.pid"
    [ -f "$pid_file" ] && kill "$(cat "$pid_file")" 2>/dev/null || true
    rm -f "$DATA/sandboxes/$id/.meta/fc.sock"
    rm -f "$DATA/sandboxes/$id/.meta/vsock.sock"
}

# Hot-add a drive (for activate_module)
# Usage: sq-firecracker add-drive <sandbox-id> <drive-id> <squashfs-path>
fc_add_drive() {
    local id="$1" drive_id="$2" sqfs_path="$3"
    local sock="$DATA/sandboxes/$id/.meta/fc.sock"

    jq -n --arg did "$drive_id" --arg path "$sqfs_path" \
        '{drive_id:$did,path_on_host:$path,is_root_device:false,is_read_only:true}' \
    | curl -s --unix-socket "$sock" -X PUT "http://localhost/drives/$drive_id" \
        -H 'Content-Type: application/json' -d @-

    # Tell guest to remount overlayfs with new drive
    local cid=$(cat "$DATA/sandboxes/$id/.meta/fc.cid")
    echo '{"cmd":"__squash_remount"}' | socat - VSOCK-CONNECT:$cid:5000
}

case "${1:-help}" in
    start)     shift; fc_start "$@" ;;
    exec)      shift; fc_exec "$@" ;;
    stop)      shift; fc_stop "$@" ;;
    add-drive) shift; fc_add_drive "$@" ;;
    help|*)
        cat <<'EOF'
usage: sq-firecracker <command> [args]

  start     <id> <cpu> <mem_mb> <sqfs...>   boot a microVM
  exec      <id> <cmd> [workdir] [timeout]  run command via vsock
  stop      <id>                            kill VM and clean up
  add-drive <id> <drive-id> <sqfs-path>     hot-add squashfs drive
EOF
        ;;
esac
